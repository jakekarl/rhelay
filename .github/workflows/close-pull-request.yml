name: Close Pull Request

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: write

jobs:
  delete-promotion-branch:
    runs-on: ubuntu-latest
    if: startsWith(github.head_ref, 'promotion__') && github.event.pull_request.merged == true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Delete promotion branch
        env:
          BRANCH_NAME: ${{ github.head_ref }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Deleting promotional branch: $BRANCH_NAME"
          git push origin --delete "$BRANCH_NAME" || {
            echo "Warning: Could not delete branch $BRANCH_NAME. It may have already been deleted."
            exit 0
          }

      - name: Confirm deletion
        run: |
          echo "✅ Promotional branch ${{ github.head_ref }} has been deleted"

  create-next-promotion:
    runs-on: ubuntu-latest
    needs: delete-promotion-branch
    if: startsWith(github.head_ref, 'promotion__') && github.event.pull_request.merged == true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create next stage promotion
        env:
          PROMOTION_BRANCH: ${{ github.head_ref }}
          TARGET_BRANCH: ${{ github.base_ref }}
        run: |
          # Extract the source and target from the promotion branch name
          # promotion__source__target -> source and target
          SOURCE_BRANCH=$(echo "$PROMOTION_BRANCH" | awk -F'__' '{print $2}')
          CURRENT_TARGET=$(echo "$PROMOTION_BRANCH" | awk -F'__' '{print $3}')
          
          echo "Source branch: $SOURCE_BRANCH"
          echo "Current target branch: $CURRENT_TARGET"
          echo "Base branch (merged into): $TARGET_BRANCH"
          
          # Find the next stage from pipeline.json
          NEXT_STAGE=$(jq -r --arg branch "$TARGET_BRANCH" '.stages | to_entries[] | select(.value.branch == $branch) | .value.next' rh/pipeline.json)
          
          if [[ -z "$NEXT_STAGE" || "$NEXT_STAGE" == "null" ]]; then
            echo "No next stage found for branch $TARGET_BRANCH. This is the final stage."
            exit 0
          fi
          
          echo "Next stage: $NEXT_STAGE"
          
          # Check if next stage is "release"
          if [[ "$NEXT_STAGE" == "release" ]]; then
            echo "Next stage is release. Looking for default release..."
            
            # Find default release
            DEFAULT_RELEASE=$(jq -r '.releases | to_entries[] | select(.value.default == true) | .key' rh/pipeline.json)
            
            if [[ -z "$DEFAULT_RELEASE" || "$DEFAULT_RELEASE" == "null" ]]; then
              echo "No default release found. Creating a new release branch..."
              
              # Fetch all branches to check existing releases
              git fetch origin --prune
              
              # Find existing release branches
              REMOTE_RELEASES=$(git ls-remote --heads origin 'refs/heads/release__*' 2>/dev/null | awk '{print $2}' | sed 's#refs/heads/##' | grep -E '^release__[A-Za-z]$' || true)
              
              MAX_ORD=0
              while IFS= read -r rb; do
                if [[ -z "$rb" ]]; then
                  continue
                fi
                letter=$(echo "$rb" | sed -E 's/^release__([A-Za-z])$/\1/')
                letter=$(echo "$letter" | tr '[:lower:]' '[:upper:]')
                ord=$(printf '%d' "'${letter}")
                if [[ $ord -gt $MAX_ORD ]]; then
                  MAX_ORD=$ord
                fi
              done <<< "$REMOTE_RELEASES"
              
              if [[ $MAX_ORD -eq 0 ]]; then
                NEXT_LETTER='A'
              else
                if [[ $MAX_ORD -ge 90 ]]; then
                  echo "Error: existing release branches reached 'Z'. Cannot create next release letter." >&2
                  exit 1
                fi
                NEXT_LETTER=$(printf "\\$(printf '%03o' $((MAX_ORD + 1)))")
              fi
              
              RELEASE_BRANCH="release__${NEXT_LETTER}"
              echo "Creating new release branch: $RELEASE_BRANCH"
              
              # Get production branch
              PROD_BRANCH=$(jq -r '.stages.production.branch' rh/pipeline.json)
              
              # Create release branch from production
              git fetch origin "$PROD_BRANCH"
              git checkout -b "$RELEASE_BRANCH" "origin/$PROD_BRANCH"
              git push origin "$RELEASE_BRANCH"
              
              echo "✅ Created new release branch: $RELEASE_BRANCH"
              
              # Add release to pipeline.json on production branch
              echo "Adding $RELEASE_BRANCH to pipeline.json..."
              
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              
              # Checkout production branch
              git fetch origin "$PROD_BRANCH"
              git checkout "$PROD_BRANCH"
              git pull origin "$PROD_BRANCH"
              
              # Check if there's already a default release
              EXISTING_DEFAULT=$(jq -r '.releases | to_entries[] | select(.value.default == true) | .key' rh/pipeline.json)
              
              if [[ -n "$EXISTING_DEFAULT" ]]; then
                DEFAULT_VALUE="false"
              else
                DEFAULT_VALUE="true"
              fi
              
              # Add release to pipeline.json
              jq --arg branch "$RELEASE_BRANCH" \
                 --argjson default "$DEFAULT_VALUE" \
                 '.releases[$branch] = {
                   "default": $default,
                   "branch": $branch,
                   "next": "production",
                   "tickets": []
                 }' rh/pipeline.json > rh/pipeline.json.tmp
              
              mv rh/pipeline.json.tmp rh/pipeline.json
              
              git add rh/pipeline.json
              git commit -m "Register release branch: $RELEASE_BRANCH"
              git push origin "$PROD_BRANCH"
              
              echo "✅ Added $RELEASE_BRANCH to pipeline.json on $PROD_BRANCH"
              
              DEFAULT_RELEASE="release__${NEXT_LETTER}"
            fi
            
            echo "Found default release: $DEFAULT_RELEASE"
            RELEASE_BRANCH=$(jq -r --arg key "$DEFAULT_RELEASE" '.releases[$key].branch' rh/pipeline.json)
            echo "Release branch: $RELEASE_BRANCH"
            
            # Create promotion branch to release
            NEW_PROMOTION_BRANCH="promotion__${SOURCE_BRANCH}__${RELEASE_BRANCH}"
            echo "Creating promotion branch: $NEW_PROMOTION_BRANCH"
            
            # Configure git
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Fetch latest changes
            git fetch origin "$SOURCE_BRANCH"
            git fetch origin "$RELEASE_BRANCH" || true
            
            # Check if there are commits between release and source
            COMMITS_AHEAD=$(git rev-list --count "origin/$RELEASE_BRANCH..origin/$SOURCE_BRANCH" 2>/dev/null || echo "0")
            
            if [[ "$COMMITS_AHEAD" -eq 0 ]]; then
              echo "No commits to promote from $SOURCE_BRANCH to $RELEASE_BRANCH. Skipping promotion creation."
              exit 0
            fi
            
            echo "Found $COMMITS_AHEAD commits to promote"
            
            # Create promotion branch from source branch
            git checkout -b "$NEW_PROMOTION_BRANCH" "origin/$SOURCE_BRANCH"
            
            # Push the new promotion branch
            git push origin "$NEW_PROMOTION_BRANCH"
            
            echo "✅ Created promotion branch: $NEW_PROMOTION_BRANCH"
            
            # Now create promotion from release to production
            PROD_BRANCH=$(jq -r '.stages.production.branch' rh/pipeline.json)
            RELEASE_TO_PROD_BRANCH="promotion__${RELEASE_BRANCH}__${PROD_BRANCH}"
            
            echo "Creating release to production promotion: $RELEASE_TO_PROD_BRANCH"
            
            git checkout -b "$RELEASE_TO_PROD_BRANCH" "origin/$RELEASE_BRANCH" || git checkout "$RELEASE_TO_PROD_BRANCH"
            git push origin "$RELEASE_TO_PROD_BRANCH"
            
            echo "✅ Created release to production promotion branch: $RELEASE_TO_PROD_BRANCH"
          else
            # Get the branch name for the next stage
            NEXT_BRANCH=$(jq -r --arg stage "$NEXT_STAGE" '.stages[$stage].branch' rh/pipeline.json)
            
            if [[ -z "$NEXT_BRANCH" || "$NEXT_BRANCH" == "null" ]]; then
              echo "Could not find branch for next stage $NEXT_STAGE"
              exit 1
            fi
            
            echo "Next branch: $NEXT_BRANCH"
            
            # Create new promotion branch name using the original source
            NEW_PROMOTION_BRANCH="promotion__${SOURCE_BRANCH}__${NEXT_BRANCH}"
            echo "Creating new promotion branch: $NEW_PROMOTION_BRANCH"
            
            # Configure git
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            
            # Fetch latest changes
            git fetch origin "$SOURCE_BRANCH"
            git fetch origin "$NEXT_BRANCH" || true
            
            # Check if there are commits between next stage and source
            COMMITS_AHEAD=$(git rev-list --count "origin/$NEXT_BRANCH..origin/$SOURCE_BRANCH" 2>/dev/null || echo "0")
            
            if [[ "$COMMITS_AHEAD" -eq 0 ]]; then
              echo "No commits to promote from $SOURCE_BRANCH to $NEXT_BRANCH. Skipping promotion creation."
              exit 0
            fi
            
            echo "Found $COMMITS_AHEAD commits to promote"
            
            # Create promotion branch from source branch
            git checkout -b "$NEW_PROMOTION_BRANCH" "origin/$SOURCE_BRANCH"
            
            # Push the new promotion branch
            git push origin "$NEW_PROMOTION_BRANCH"
            
            echo "✅ Created promotion branch: $NEW_PROMOTION_BRANCH"
          fi

  create-next-pr:
    runs-on: ubuntu-latest
    needs: create-next-promotion
    if: startsWith(github.head_ref, 'promotion__') && github.event.pull_request.merged == true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create PR for next stage
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PROMOTION_BRANCH: ${{ github.head_ref }}
          TARGET_BRANCH: ${{ github.base_ref }}
        run: |
          # Extract source from promotion branch
          SOURCE_BRANCH=$(echo "$PROMOTION_BRANCH" | awk -F'__' '{print $2}')
          
          # Extract target and find next stage
          NEXT_STAGE=$(jq -r --arg branch "$TARGET_BRANCH" '.stages | to_entries[] | select(.value.branch == $branch) | .value.next' rh/pipeline.json)
          
          if [[ -z "$NEXT_STAGE" || "$NEXT_STAGE" == "null" ]]; then
            echo "No PR to create - this is the final stage"
            exit 0
          fi
          
          # Check if next stage is "release"
          if [[ "$NEXT_STAGE" == "release" ]]; then
            echo "Next stage is release. Creating PR to default release."
            
            # Find default release
            DEFAULT_RELEASE=$(jq -r '.releases | to_entries[] | select(.value.default == true) | .key' rh/pipeline.json)
            
            if [[ -z "$DEFAULT_RELEASE" || "$DEFAULT_RELEASE" == "null" ]]; then
              echo "No default release found. Skipping PR creation."
              exit 0
            fi
            
            RELEASE_BRANCH=$(jq -r --arg key "$DEFAULT_RELEASE" '.releases[$key].branch' rh/pipeline.json)
            NEW_PROMOTION_BRANCH="promotion__${SOURCE_BRANCH}__${RELEASE_BRANCH}"
            
            # Create PR to release
            gh pr create \
              --base "$RELEASE_BRANCH" \
              --head "$NEW_PROMOTION_BRANCH" \
              --title "[rHelay] $SOURCE_BRANCH → $RELEASE_BRANCH" \
              --body "Automated promotion from \`$SOURCE_BRANCH\` to \`$RELEASE_BRANCH\`

            This PR was automatically created after merging the previous promotion.

            **Source Branch:** \`$SOURCE_BRANCH\`
            **Target Branch:** \`$RELEASE_BRANCH\`
            **Promotion Branch:** \`$NEW_PROMOTION_BRANCH\`" || {
              echo "Note: PR may already exist or could not be created"
              exit 0
            }
            
            echo "✅ Created PR for $NEW_PROMOTION_BRANCH → $RELEASE_BRANCH"
            
            # Create PR from release to production
            PROD_BRANCH=$(jq -r '.stages.production.branch' rh/pipeline.json)
            RELEASE_TO_PROD_BRANCH="promotion__${RELEASE_BRANCH}__${PROD_BRANCH}"
            
            gh pr create \
              --base "$PROD_BRANCH" \
              --head "$RELEASE_TO_PROD_BRANCH" \
              --title "[rHelay] $RELEASE_BRANCH → $PROD_BRANCH" \
              --body "Automated promotion from \`$RELEASE_BRANCH\` to \`$PROD_BRANCH\`

            This PR promotes the release branch to production.

            **Source Branch:** \`$RELEASE_BRANCH\`
            **Target Branch:** \`$PROD_BRANCH\`
            **Promotion Branch:** \`$RELEASE_TO_PROD_BRANCH\`" || {
              echo "Note: PR may already exist or could not be created"
              exit 0
            }
            
            echo "✅ Created PR for $RELEASE_TO_PROD_BRANCH → $PROD_BRANCH"
          else
            NEXT_BRANCH=$(jq -r --arg stage "$NEXT_STAGE" '.stages[$stage].branch' rh/pipeline.json)
            NEW_PROMOTION_BRANCH="promotion__${SOURCE_BRANCH}__${NEXT_BRANCH}"
            
            # Create PR using GitHub CLI
            gh pr create \
              --base "$NEXT_BRANCH" \
              --head "$NEW_PROMOTION_BRANCH" \
              --title "[rHelay] $SOURCE_BRANCH → $NEXT_BRANCH" \
              --body "Automated promotion from \`$SOURCE_BRANCH\` to \`$NEXT_BRANCH\`

            This PR was automatically created after merging the previous promotion.

            **Source Branch:** \`$SOURCE_BRANCH\`
            **Target Branch:** \`$NEXT_BRANCH\`
            **Promotion Branch:** \`$NEW_PROMOTION_BRANCH\`" || {
              echo "Note: PR may already exist or could not be created"
              exit 0
            }
            
            echo "✅ Created PR for $NEW_PROMOTION_BRANCH → $NEXT_BRANCH"
          fi
